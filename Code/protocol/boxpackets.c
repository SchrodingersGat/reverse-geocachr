// boxpackets.c was generated by ProtoGen version 2.4.b

#include "boxpackets.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Create the Reset packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeResetPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getResetPacketID());
}

/*!
 * \brief Decode the Reset packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeResetPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getResetPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the Unlock packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeUnlockPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getUnlockPacketID());
}

/*!
 * \brief Decode the Unlock packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeUnlockPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getUnlockPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the Lock packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeLockPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getLockPacketID());
}

/*!
 * \brief Decode the Lock packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeLockPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getLockPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the NextClue packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeNextCluePacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getNextCluePacketID());
}

/*!
 * \brief Decode the NextClue packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeNextCluePacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getNextCluePacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the PrevClue packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodePrevCluePacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getPrevCluePacketID());
}

/*!
 * \brief Decode the PrevClue packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodePrevCluePacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getPrevCluePacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the FirstClue packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeFirstCluePacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getFirstCluePacketID());
}

/*!
 * \brief Decode the FirstClue packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeFirstCluePacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getFirstCluePacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the LastClue packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeLastCluePacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getLastCluePacketID());
}

/*!
 * \brief Decode the LastClue packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeLastCluePacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getLastCluePacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the Bootload packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeBootloadPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getBootloadPacketID());
}

/*!
 * \brief Decode the Bootload packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeBootloadPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getBootloadPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the EnableDebug packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeEnableDebugPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getEnableDebugPacketID());
}

/*!
 * \brief Decode the EnableDebug packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeEnableDebugPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getEnableDebugPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the SetClueCount packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param clueCount is 
 */
void encodeSetClueCountPacket(void* pkt, uint8_t clueCount)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    uint8ToBytes((uint8_t)clueCount, data, &byteindex);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getSetClueCountPacketID());
}

/*!
 * \brief Decode the SetClueCount packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param clueCount receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeSetClueCountPacket(const void* pkt, uint8_t* clueCount)
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getSetClueCountPacketID())
        return 0;

    if(numBytes < getSetClueCountMinDataLength())
        return 0;

    *clueCount = (uint8_t)uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the ValidateClues packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeValidateCluesPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getValidateCluesPacketID());
}

/*!
 * \brief Decode the ValidateClues packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeValidateCluesPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getValidateCluesPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the InvalidateClues packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeInvalidateCluesPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getInvalidateCluesPacketID());
}

/*!
 * \brief Decode the InvalidateClues packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeInvalidateCluesPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getInvalidateCluesPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the BoxInfo packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param info is 
 */
void encodeBoxInfoPacket(void* pkt, const BoxInfo_t* info)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    encodeBoxInfo_t(data, &byteindex, info);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getBoxInfoPacketID());
}

/*!
 * \brief Decode the BoxInfo packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param info receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeBoxInfoPacket(const void* pkt, BoxInfo_t* info)
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getBoxInfoPacketID())
        return 0;

    if(numBytes < getBoxInfoMinDataLength())
        return 0;

    if(decodeBoxInfo_t(data, &byteindex, info) == 0)
        return 0;

    return 1;
}

/*!
 * \brief Create the RequestBoxInfo packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeRequestBoxInfoPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getRequestBoxInfoPacketID());
}

/*!
 * \brief Decode the RequestBoxInfo packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeRequestBoxInfoPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getRequestBoxInfoPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the ClueInfo packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param clueNumber is 
 * \param clueInfo is 
 */
void encodeClueInfoPacket(void* pkt, uint8_t clueNumber, const Waypoint_t* clueInfo)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    uint8ToBytes((uint8_t)clueNumber, data, &byteindex);

    encodeWaypoint_t(data, &byteindex, clueInfo);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getClueInfoPacketID());
}

/*!
 * \brief Decode the ClueInfo packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param clueNumber receives 
 * \param clueInfo receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeClueInfoPacket(const void* pkt, uint8_t* clueNumber, Waypoint_t* clueInfo)
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getClueInfoPacketID())
        return 0;

    if(numBytes < getClueInfoMinDataLength())
        return 0;

    *clueNumber = (uint8_t)uint8FromBytes(data, &byteindex);

    if(decodeWaypoint_t(data, &byteindex, clueInfo) == 0)
        return 0;

    return 1;
}

/*!
 * \brief Create the RequestClueInfo packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param clueNumber is 
 */
void encodeRequestClueInfoPacket(void* pkt, uint8_t clueNumber)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    uint8ToBytes((uint8_t)clueNumber, data, &byteindex);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getRequestClueInfoPacketID());
}

/*!
 * \brief Decode the RequestClueInfo packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param clueNumber receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeRequestClueInfoPacket(const void* pkt, uint8_t* clueNumber)
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getRequestClueInfoPacketID())
        return 0;

    if(numBytes < getRequestClueInfoMinDataLength())
        return 0;

    *clueNumber = (uint8_t)uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the ClueLine packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param clueNumber is Index of clue
 * \param lineNumber is Line number
 * \param lineText is Line data
 */
void encodeClueLinePacket(void* pkt, uint8_t clueNumber, uint8_t lineNumber, const char lineText[40])
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    // Index of clue
    uint8ToBytes((uint8_t)clueNumber, data, &byteindex);

    // Line number
    uint8ToBytes((uint8_t)lineNumber, data, &byteindex);

    // Line data
    stringToBytes(lineText, data, &byteindex, 40, 0);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getClueLinePacketID());
}

/*!
 * \brief Decode the ClueLine packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param clueNumber receives Index of clue
 * \param lineNumber receives Line number
 * \param lineText receives Line data
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeClueLinePacket(const void* pkt, uint8_t* clueNumber, uint8_t* lineNumber, char lineText[40])
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getClueLinePacketID())
        return 0;

    if(numBytes < getClueLineMinDataLength())
        return 0;

    // Index of clue
    *clueNumber = (uint8_t)uint8FromBytes(data, &byteindex);

    // Line number
    *lineNumber = (uint8_t)uint8FromBytes(data, &byteindex);

    // Line data
    stringFromBytes(lineText, data, &byteindex, 40, 0);

    return 1;
}

/*!
 * \brief Create the RequestClueLine packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param clueNumber is 
 * \param lineNumber is 
 */
void encodeRequestClueLinePacket(void* pkt, uint8_t clueNumber, uint8_t lineNumber)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    uint8ToBytes((uint8_t)clueNumber, data, &byteindex);

    uint8ToBytes((uint8_t)lineNumber, data, &byteindex);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getRequestClueLinePacketID());
}

/*!
 * \brief Decode the RequestClueLine packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param clueNumber receives 
 * \param lineNumber receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeRequestClueLinePacket(const void* pkt, uint8_t* clueNumber, uint8_t* lineNumber)
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getRequestClueLinePacketID())
        return 0;

    if(numBytes < getRequestClueLineMinDataLength())
        return 0;

    *clueNumber = (uint8_t)uint8FromBytes(data, &byteindex);

    *lineNumber = (uint8_t)uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Set a Settings_t structure to initial values.
 *
 * Set a Settings_t structure to initial values. Not all fields are set,
 * only those which the protocol specifies.
 * \param user is the structure whose data are set to initial values
 */
void initSettings_t(Settings_t* user)
{

    // Box settings
    initBoxSettings_t(&user->settings);

}// initSettings_t

/*!
 * \brief Verify a Settings_t structure has acceptable values.
 *
 * Verify a Settings_t structure has acceptable values. Not all fields are
 * verified, only those which the protocol specifies. Fields which are outside
 * the allowable range are changed to the maximum or minimum allowable value. 
 * \param user is the structure whose data are verified
 * \return 1 if all verifiable data where valid, else 0 if data had to be corrected
 */
int verifySettings_t(Settings_t* user)
{
    int good = 1;

    // Box settings
    if(!verifyBoxSettings_t(&user->settings))
        good = 0;

    return good;

}// verifySettings_t

/*!
 * \brief Create the Settings packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeSettingsPacketStructure(void* pkt, const Settings_t* user)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    // Box settings
    encodeBoxSettings_t(data, &byteindex, &user->settings);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getSettingsPacketID());
}

/*!
 * \brief Decode the Settings packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeSettingsPacketStructure(const void* pkt, Settings_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getSettingsPacketID())
        return 0;

    // Verify the packet size
    numBytes = getReverseGeocachePacketSize(pkt);
    if(numBytes < getSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    data = getReverseGeocachePacketDataConst(pkt);

    // Box settings
    if(decodeBoxSettings_t(data, &byteindex, &user->settings) == 0)
        return 0;

    return 1;
}

/*!
 * \brief Create the Settings packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param settings is Box settings
 */
void encodeSettingsPacket(void* pkt, const BoxSettings_t* settings)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    // Box settings
    encodeBoxSettings_t(data, &byteindex, settings);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getSettingsPacketID());
}

/*!
 * \brief Decode the Settings packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param settings receives Box settings
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeSettingsPacket(const void* pkt, BoxSettings_t* settings)
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getSettingsPacketID())
        return 0;

    if(numBytes < getSettingsMinDataLength())
        return 0;

    // Box settings
    if(decodeBoxSettings_t(data, &byteindex, settings) == 0)
        return 0;

    return 1;
}

/*!
 * \brief Create the RequestSettings packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeRequestSettingsPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getRequestSettingsPacketID());
}

/*!
 * \brief Decode the RequestSettings packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeRequestSettingsPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getRequestSettingsPacketID())
        return 0;
    else
        return 1;
}
// end of boxpackets.c
