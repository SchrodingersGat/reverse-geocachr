// boxpackets.c was generated by ProtoGen version 2.4.b

#include "boxpackets.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Create the Reset packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeResetPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getResetPacketID());
}

/*!
 * \brief Decode the Reset packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeResetPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getResetPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the Unlock packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeUnlockPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getUnlockPacketID());
}

/*!
 * \brief Decode the Unlock packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeUnlockPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getUnlockPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the Lock packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeLockPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getLockPacketID());
}

/*!
 * \brief Decode the Lock packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeLockPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getLockPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the UnlockSettings packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param password is 
 */
void encodeUnlockSettingsPacket(void* pkt, const char password[32])
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    stringToBytes(password, data, &byteindex, 32, 0);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getUnlockSettingsPacketID());
}

/*!
 * \brief Decode the UnlockSettings packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param password receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeUnlockSettingsPacket(const void* pkt, char password[32])
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getUnlockSettingsPacketID())
        return 0;

    if(numBytes < getUnlockSettingsMinDataLength())
        return 0;

    stringFromBytes(password, data, &byteindex, 32, 0);

    return 1;
}

/*!
 * \brief Create the LockSettings packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param password is 
 */
void encodeLockSettingsPacket(void* pkt, const char password[32])
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    stringToBytes(password, data, &byteindex, 32, 0);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getLockSettingsPacketID());
}

/*!
 * \brief Decode the LockSettings packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param password receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeLockSettingsPacket(const void* pkt, char password[32])
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getLockSettingsPacketID())
        return 0;

    if(numBytes < getLockSettingsMinDataLength())
        return 0;

    stringFromBytes(password, data, &byteindex, 32, 0);

    return 1;
}

/*!
 * \brief Create the NextClue packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeNextCluePacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getNextCluePacketID());
}

/*!
 * \brief Decode the NextClue packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeNextCluePacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getNextCluePacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the PrevClue packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodePrevCluePacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getPrevCluePacketID());
}

/*!
 * \brief Decode the PrevClue packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodePrevCluePacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getPrevCluePacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the FirstClue packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeFirstCluePacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getFirstCluePacketID());
}

/*!
 * \brief Decode the FirstClue packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeFirstCluePacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getFirstCluePacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the LastClue packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeLastCluePacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getLastCluePacketID());
}

/*!
 * \brief Decode the LastClue packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeLastCluePacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getLastCluePacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the EnableDebug packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param debugOn is Turn debug mode on (or off)
 */
void encodeEnableDebugPacket(void* pkt, uint8_t debugOn)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    // Turn debug mode on (or off)
    uint8ToBytes((uint8_t)debugOn, data, &byteindex);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getEnableDebugPacketID());
}

/*!
 * \brief Decode the EnableDebug packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param debugOn receives Turn debug mode on (or off)
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeEnableDebugPacket(const void* pkt, uint8_t* debugOn)
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getEnableDebugPacketID())
        return 0;

    if(numBytes < getEnableDebugMinDataLength())
        return 0;

    // Turn debug mode on (or off)
    *debugOn = (uint8_t)uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the SetClueCount packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param clueCount is 
 */
void encodeSetClueCountPacket(void* pkt, uint8_t clueCount)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    uint8ToBytes((uint8_t)clueCount, data, &byteindex);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getSetClueCountPacketID());
}

/*!
 * \brief Decode the SetClueCount packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param clueCount receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeSetClueCountPacket(const void* pkt, uint8_t* clueCount)
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getSetClueCountPacketID())
        return 0;

    if(numBytes < getSetClueCountMinDataLength())
        return 0;

    *clueCount = (uint8_t)uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the ValidateClues packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeValidateCluesPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getValidateCluesPacketID());
}

/*!
 * \brief Decode the ValidateClues packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeValidateCluesPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getValidateCluesPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the InvalidateClues packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeInvalidateCluesPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getInvalidateCluesPacketID());
}

/*!
 * \brief Decode the InvalidateClues packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeInvalidateCluesPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getInvalidateCluesPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the BoxStatus packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeBoxStatusPacketStructure(void* pkt, const BoxStatus_t* user)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    // State machine status
    uint8ToBytes((uint8_t)user->state, data, &byteindex);

    data[byteindex] = (uint8_t)user->locked << 7;
    byteindex += 1; // close bit field

    // Battery charge estimate, 0% to 100%
    uint8ToBytes((uint8_t)user->charge, data, &byteindex);

    // Box is protected with password
    data[byteindex] = (uint8_t)user->passwordProtected << 7;

    // 1 = GPS unit detected
    data[byteindex] |= (uint8_t)user->gpsConnection << 6;

    // GPS Status
    data[byteindex] |= (uint8_t)user->gpsStatus << 4;

    // Battery charging status
    data[byteindex] |= (uint8_t)user->charging << 3;

    data[byteindex] |= (uint8_t)user->debug << 2;

    // Settings could not be loaded from EEPROM
    data[byteindex] |= (uint8_t)user->settingsError << 1;
    byteindex += 1; // close bit field

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getBoxStatusPacketID());
}

/*!
 * \brief Decode the BoxStatus packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeBoxStatusPacketStructure(const void* pkt, BoxStatus_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getBoxStatusPacketID())
        return 0;

    // Verify the packet size
    numBytes = getReverseGeocachePacketSize(pkt);
    if(numBytes < getBoxStatusMinDataLength())
        return 0;

    // The raw data from the packet
    data = getReverseGeocachePacketDataConst(pkt);

    // State machine status
    user->state = (uint8_t)uint8FromBytes(data, &byteindex);

    user->locked = (data[byteindex] >> 7);
    byteindex += 1; // close bit field

    // Battery charge estimate, 0% to 100%
    user->charge = (uint8_t)uint8FromBytes(data, &byteindex);

    // Box is protected with password
    user->passwordProtected = (data[byteindex] >> 7);

    // 1 = GPS unit detected
    user->gpsConnection = ((data[byteindex] >> 6) & 0x1);

    // GPS Status
    user->gpsStatus = ((data[byteindex] >> 4) & 0x3);

    // Battery charging status
    user->charging = ((data[byteindex] >> 3) & 0x1);

    user->debug = ((data[byteindex] >> 2) & 0x1);

    // Settings could not be loaded from EEPROM
    user->settingsError = ((data[byteindex] >> 1) & 0x1);
    byteindex += 1; // close bit field

    return 1;
}

/*!
 * \brief Create the BoxStatus packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param state is State machine status
 * \param locked is 
 * \param charge is Battery charge estimate, 0% to 100%
 * \param passwordProtected is Box is protected with password
 * \param gpsConnection is 1 = GPS unit detected
 * \param gpsStatus is GPS Status
 * \param charging is Battery charging status
 * \param debug is 
 * \param settingsError is Settings could not be loaded from EEPROM
 */
void encodeBoxStatusPacket(void* pkt, uint8_t state, unsigned locked, uint8_t charge, unsigned passwordProtected, unsigned gpsConnection, unsigned gpsStatus, unsigned charging, unsigned debug, unsigned settingsError)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    // State machine status
    uint8ToBytes((uint8_t)state, data, &byteindex);

    data[byteindex] = (uint8_t)locked << 7;
    byteindex += 1; // close bit field

    // Battery charge estimate, 0% to 100%
    uint8ToBytes((uint8_t)charge, data, &byteindex);

    // Box is protected with password
    data[byteindex] = (uint8_t)passwordProtected << 7;

    // 1 = GPS unit detected
    data[byteindex] |= (uint8_t)gpsConnection << 6;

    // GPS Status
    data[byteindex] |= (uint8_t)gpsStatus << 4;

    // Battery charging status
    data[byteindex] |= (uint8_t)charging << 3;

    data[byteindex] |= (uint8_t)debug << 2;

    // Settings could not be loaded from EEPROM
    data[byteindex] |= (uint8_t)settingsError << 1;
    byteindex += 1; // close bit field

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getBoxStatusPacketID());
}

/*!
 * \brief Decode the BoxStatus packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param state receives State machine status
 * \param locked receives 
 * \param charge receives Battery charge estimate, 0% to 100%
 * \param passwordProtected receives Box is protected with password
 * \param gpsConnection receives 1 = GPS unit detected
 * \param gpsStatus receives GPS Status
 * \param charging receives Battery charging status
 * \param debug receives 
 * \param settingsError receives Settings could not be loaded from EEPROM
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeBoxStatusPacket(const void* pkt, uint8_t* state, unsigned* locked, uint8_t* charge, unsigned* passwordProtected, unsigned* gpsConnection, unsigned* gpsStatus, unsigned* charging, unsigned* debug, unsigned* settingsError)
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getBoxStatusPacketID())
        return 0;

    if(numBytes < getBoxStatusMinDataLength())
        return 0;

    // State machine status
    *state = (uint8_t)uint8FromBytes(data, &byteindex);

    (*locked) = (data[byteindex] >> 7);
    byteindex += 1; // close bit field

    // Battery charge estimate, 0% to 100%
    *charge = (uint8_t)uint8FromBytes(data, &byteindex);

    // Box is protected with password
    (*passwordProtected) = (data[byteindex] >> 7);

    // 1 = GPS unit detected
    (*gpsConnection) = ((data[byteindex] >> 6) & 0x1);

    // GPS Status
    (*gpsStatus) = ((data[byteindex] >> 4) & 0x3);

    // Battery charging status
    (*charging) = ((data[byteindex] >> 3) & 0x1);

    (*debug) = ((data[byteindex] >> 2) & 0x1);

    // Settings could not be loaded from EEPROM
    (*settingsError) = ((data[byteindex] >> 1) & 0x1);
    byteindex += 1; // close bit field

    return 1;
}

/*!
 * \brief Create the RequestBoxStatus packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeRequestBoxStatusPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getRequestBoxStatusPacketID());
}

/*!
 * \brief Decode the RequestBoxStatus packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeRequestBoxStatusPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getRequestBoxStatusPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Set a BoxSettings_t structure to initial values.
 *
 * Set a BoxSettings_t structure to initial values. Not all fields are set,
 * only those which the protocol specifies.
 * \param user is the structure whose data are set to initial values
 */
void initBoxSettings_t(BoxSettings_t* user)
{

    // Total number of clues
    user->totalClues = 0;

    // Current clue index
    user->currentClue = 0;

    // PWM value for locked position
    user->pwmLocked = 1000;

    // PWM value for unlocked position
    user->pwmUnlocked = 2000;

}// initBoxSettings_t

/*!
 * \brief Verify a BoxSettings_t structure has acceptable values.
 *
 * Verify a BoxSettings_t structure has acceptable values. Not all fields are
 * verified, only those which the protocol specifies. Fields which are outside
 * the allowable range are changed to the maximum or minimum allowable value. 
 * \param user is the structure whose data are verified
 * \return 1 if all verifiable data where valid, else 0 if data had to be corrected
 */
int verifyBoxSettings_t(BoxSettings_t* user)
{
    int good = 1;

    // PWM value for locked position
    if(user->pwmLocked < 500)
    {
        user->pwmLocked = 500;
        good = 0;
    }
    else if(user->pwmLocked > 2500)
    {
        user->pwmLocked = 2500;
        good = 0;
    }

    // PWM value for unlocked position
    if(user->pwmUnlocked < 500)
    {
        user->pwmUnlocked = 500;
        good = 0;
    }
    else if(user->pwmUnlocked > 2500)
    {
        user->pwmUnlocked = 2500;
        good = 0;
    }

    return good;

}// verifyBoxSettings_t

/*!
 * \brief Create the BoxSettings packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeBoxSettingsPacketStructure(void* pkt, const BoxSettings_t* user)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    // Total number of clues
    uint8ToBytes((uint8_t)user->totalClues, data, &byteindex);

    // Current clue index
    uint8ToBytes((uint8_t)user->currentClue, data, &byteindex);

    // PWM value for locked position
    uint16ToBeBytes((uint16_t)user->pwmLocked, data, &byteindex);

    // PWM value for unlocked position
    uint16ToBeBytes((uint16_t)user->pwmUnlocked, data, &byteindex);

    // Password
    stringToBytes(user->password, data, &byteindex, 32, 0);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getBoxSettingsPacketID());
}

/*!
 * \brief Decode the BoxSettings packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeBoxSettingsPacketStructure(const void* pkt, BoxSettings_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getBoxSettingsPacketID())
        return 0;

    // Verify the packet size
    numBytes = getReverseGeocachePacketSize(pkt);
    if(numBytes < getBoxSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    data = getReverseGeocachePacketDataConst(pkt);

    // Total number of clues
    user->totalClues = (uint8_t)uint8FromBytes(data, &byteindex);

    // Current clue index
    user->currentClue = (uint8_t)uint8FromBytes(data, &byteindex);

    // PWM value for locked position
    user->pwmLocked = (uint16_t)uint16FromBeBytes(data, &byteindex);

    // PWM value for unlocked position
    user->pwmUnlocked = (uint16_t)uint16FromBeBytes(data, &byteindex);

    // Password
    stringFromBytes(user->password, data, &byteindex, 32, 0);

    return 1;
}

/*!
 * \brief Create the BoxSettings packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param totalClues is Total number of clues
 * \param currentClue is Current clue index
 * \param pwmLocked is PWM value for locked position
 * \param pwmUnlocked is PWM value for unlocked position
 * \param password is Password
 */
void encodeBoxSettingsPacket(void* pkt, uint8_t totalClues, uint8_t currentClue, uint16_t pwmLocked, uint16_t pwmUnlocked, const char password[32])
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    // Total number of clues
    uint8ToBytes((uint8_t)totalClues, data, &byteindex);

    // Current clue index
    uint8ToBytes((uint8_t)currentClue, data, &byteindex);

    // PWM value for locked position
    uint16ToBeBytes((uint16_t)pwmLocked, data, &byteindex);

    // PWM value for unlocked position
    uint16ToBeBytes((uint16_t)pwmUnlocked, data, &byteindex);

    // Password
    stringToBytes(password, data, &byteindex, 32, 0);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getBoxSettingsPacketID());
}

/*!
 * \brief Decode the BoxSettings packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param totalClues receives Total number of clues
 * \param currentClue receives Current clue index
 * \param pwmLocked receives PWM value for locked position
 * \param pwmUnlocked receives PWM value for unlocked position
 * \param password receives Password
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeBoxSettingsPacket(const void* pkt, uint8_t* totalClues, uint8_t* currentClue, uint16_t* pwmLocked, uint16_t* pwmUnlocked, char password[32])
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getBoxSettingsPacketID())
        return 0;

    if(numBytes < getBoxSettingsMinDataLength())
        return 0;

    // Total number of clues
    *totalClues = (uint8_t)uint8FromBytes(data, &byteindex);

    // Current clue index
    *currentClue = (uint8_t)uint8FromBytes(data, &byteindex);

    // PWM value for locked position
    *pwmLocked = (uint16_t)uint16FromBeBytes(data, &byteindex);

    // PWM value for unlocked position
    *pwmUnlocked = (uint16_t)uint16FromBeBytes(data, &byteindex);

    // Password
    stringFromBytes(password, data, &byteindex, 32, 0);

    return 1;
}

/*!
 * \brief Create the SetBoxSettings packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param pwmLocked is 
 * \param pwmUnlocked is 
 */
void encodeSetBoxSettingsPacket(void* pkt, uint16_t pwmLocked, uint16_t pwmUnlocked)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    uint16ToBeBytes((uint16_t)pwmLocked, data, &byteindex);

    uint16ToBeBytes((uint16_t)pwmUnlocked, data, &byteindex);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getSetBoxSettingsPacketID());
}

/*!
 * \brief Decode the SetBoxSettings packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param pwmLocked receives 
 * \param pwmUnlocked receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeSetBoxSettingsPacket(const void* pkt, uint16_t* pwmLocked, uint16_t* pwmUnlocked)
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getSetBoxSettingsPacketID())
        return 0;

    if(numBytes < getSetBoxSettingsMinDataLength())
        return 0;

    *pwmLocked = (uint16_t)uint16FromBeBytes(data, &byteindex);

    *pwmUnlocked = (uint16_t)uint16FromBeBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the RequestBoxSettings packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeRequestBoxSettingsPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getRequestBoxSettingsPacketID());
}

/*!
 * \brief Decode the RequestBoxSettings packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeRequestBoxSettingsPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getRequestBoxSettingsPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the BoxVersion packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeBoxVersionPacketStructure(void* pkt, const BoxVersion_t* user)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    // Box serial number
    uint16ToBeBytes((uint16_t)user->serialNumber, data, &byteindex);

    // Firmware version, major
    uint8ToBytes((uint8_t)user->versionMajor, data, &byteindex);

    // Firmware version, minor
    uint8ToBytes((uint8_t)user->versionMinor, data, &byteindex);

    // PCB revision
    uint8ToBytes((uint8_t)user->pcbRevision, data, &byteindex);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getBoxVersionPacketID());
}

/*!
 * \brief Decode the BoxVersion packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeBoxVersionPacketStructure(const void* pkt, BoxVersion_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getBoxVersionPacketID())
        return 0;

    // Verify the packet size
    numBytes = getReverseGeocachePacketSize(pkt);
    if(numBytes < getBoxVersionMinDataLength())
        return 0;

    // The raw data from the packet
    data = getReverseGeocachePacketDataConst(pkt);

    // Box serial number
    user->serialNumber = (uint16_t)uint16FromBeBytes(data, &byteindex);

    // Firmware version, major
    user->versionMajor = (uint8_t)uint8FromBytes(data, &byteindex);

    // Firmware version, minor
    user->versionMinor = (uint8_t)uint8FromBytes(data, &byteindex);

    // PCB revision
    user->pcbRevision = (uint8_t)uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the BoxVersion packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param serialNumber is Box serial number
 * \param versionMajor is Firmware version, major
 * \param versionMinor is Firmware version, minor
 * \param pcbRevision is PCB revision
 */
void encodeBoxVersionPacket(void* pkt, uint16_t serialNumber, uint8_t versionMajor, uint8_t versionMinor, uint8_t pcbRevision)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    // Box serial number
    uint16ToBeBytes((uint16_t)serialNumber, data, &byteindex);

    // Firmware version, major
    uint8ToBytes((uint8_t)versionMajor, data, &byteindex);

    // Firmware version, minor
    uint8ToBytes((uint8_t)versionMinor, data, &byteindex);

    // PCB revision
    uint8ToBytes((uint8_t)pcbRevision, data, &byteindex);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getBoxVersionPacketID());
}

/*!
 * \brief Decode the BoxVersion packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param serialNumber receives Box serial number
 * \param versionMajor receives Firmware version, major
 * \param versionMinor receives Firmware version, minor
 * \param pcbRevision receives PCB revision
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeBoxVersionPacket(const void* pkt, uint16_t* serialNumber, uint8_t* versionMajor, uint8_t* versionMinor, uint8_t* pcbRevision)
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getBoxVersionPacketID())
        return 0;

    if(numBytes < getBoxVersionMinDataLength())
        return 0;

    // Box serial number
    *serialNumber = (uint16_t)uint16FromBeBytes(data, &byteindex);

    // Firmware version, major
    *versionMajor = (uint8_t)uint8FromBytes(data, &byteindex);

    // Firmware version, minor
    *versionMinor = (uint8_t)uint8FromBytes(data, &byteindex);

    // PCB revision
    *pcbRevision = (uint8_t)uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the RequestBoxVersion packet
 *

 * \param pkt points to the packet which will be created by this function
 */
void encodeRequestBoxVersionPacket(void* pkt)
{
    // Zero length packet, no data encoded
    finishReverseGeocachePacket(pkt, 0, getRequestBoxVersionPacketID());
}

/*!
 * \brief Decode the RequestBoxVersion packet
 *

 * \param pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeRequestBoxVersionPacket(const void* pkt)
{
    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getRequestBoxVersionPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the ClueInfo packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param clueNumber is 
 * \param clueInfo is 
 * \param checksum is Waypoint checksum
 */
void encodeClueInfoPacket(void* pkt, uint8_t clueNumber, const Waypoint_t* clueInfo, uint32_t checksum)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    uint8ToBytes((uint8_t)clueNumber, data, &byteindex);

    encodeWaypoint_t(data, &byteindex, clueInfo);

    // Waypoint checksum
    uint32ToBeBytes((uint32_t)checksum, data, &byteindex);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getClueInfoPacketID());
}

/*!
 * \brief Decode the ClueInfo packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param clueNumber receives 
 * \param clueInfo receives 
 * \param checksum receives Waypoint checksum
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeClueInfoPacket(const void* pkt, uint8_t* clueNumber, Waypoint_t* clueInfo, uint32_t* checksum)
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getClueInfoPacketID())
        return 0;

    if(numBytes < getClueInfoMinDataLength())
        return 0;

    *clueNumber = (uint8_t)uint8FromBytes(data, &byteindex);

    if(decodeWaypoint_t(data, &byteindex, clueInfo) == 0)
        return 0;

    // Waypoint checksum
    *checksum = (uint32_t)uint32FromBeBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the RequestClueInfo packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param clueNumber is 
 */
void encodeRequestClueInfoPacket(void* pkt, uint8_t clueNumber)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    uint8ToBytes((uint8_t)clueNumber, data, &byteindex);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getRequestClueInfoPacketID());
}

/*!
 * \brief Decode the RequestClueInfo packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param clueNumber receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeRequestClueInfoPacket(const void* pkt, uint8_t* clueNumber)
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getRequestClueInfoPacketID())
        return 0;

    if(numBytes < getRequestClueInfoMinDataLength())
        return 0;

    *clueNumber = (uint8_t)uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the ClueLineText packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param clueNumber is Index of clue
 * \param lineNumber is Line number
 * \param lineText is Line data
 */
void encodeClueLineTextPacket(void* pkt, uint8_t clueNumber, uint8_t lineNumber, const ClueLine_t* lineText)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    // Index of clue
    uint8ToBytes((uint8_t)clueNumber, data, &byteindex);

    // Line number
    uint8ToBytes((uint8_t)lineNumber, data, &byteindex);

    // Line data
    encodeClueLine_t(data, &byteindex, lineText);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getClueLineTextPacketID());
}

/*!
 * \brief Decode the ClueLineText packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param clueNumber receives Index of clue
 * \param lineNumber receives Line number
 * \param lineText receives Line data
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeClueLineTextPacket(const void* pkt, uint8_t* clueNumber, uint8_t* lineNumber, ClueLine_t* lineText)
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getClueLineTextPacketID())
        return 0;

    if(numBytes < getClueLineTextMinDataLength())
        return 0;

    // Index of clue
    *clueNumber = (uint8_t)uint8FromBytes(data, &byteindex);

    // Line number
    *lineNumber = (uint8_t)uint8FromBytes(data, &byteindex);

    // Line data
    if(decodeClueLine_t(data, &byteindex, lineText) == 0)
        return 0;

    return 1;
}

/*!
 * \brief Create the RequestClueLine packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param clueNumber is 
 * \param lineNumber is 
 */
void encodeRequestClueLinePacket(void* pkt, uint8_t clueNumber, uint8_t lineNumber)
{
    uint8_t* data = getReverseGeocachePacketData(pkt);
    int byteindex = 0;

    uint8ToBytes((uint8_t)clueNumber, data, &byteindex);

    uint8ToBytes((uint8_t)lineNumber, data, &byteindex);

    // complete the process of creating the packet
    finishReverseGeocachePacket(pkt, byteindex, getRequestClueLinePacketID());
}

/*!
 * \brief Decode the RequestClueLine packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param clueNumber receives 
 * \param lineNumber receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeRequestClueLinePacket(const void* pkt, uint8_t* clueNumber, uint8_t* lineNumber)
{
    int byteindex = 0;
    const uint8_t* data = getReverseGeocachePacketDataConst(pkt);
    int numBytes = getReverseGeocachePacketSize(pkt);

    // Verify the packet identifier
    if(getReverseGeocachePacketID(pkt) != getRequestClueLinePacketID())
        return 0;

    if(numBytes < getRequestClueLineMinDataLength())
        return 0;

    *clueNumber = (uint8_t)uint8FromBytes(data, &byteindex);

    *lineNumber = (uint8_t)uint8FromBytes(data, &byteindex);

    return 1;
}
// end of boxpackets.c
