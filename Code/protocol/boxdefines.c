// boxdefines.c was generated by ProtoGen version 2.4.b

#include "boxdefines.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Encode a ClueOptionBits_t structure into a byte array
 *

 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodeClueOptionBits_t(uint8_t* data, int* bytecount, const ClueOptionBits_t* user)
{
    int byteindex = *bytecount;

    // Text is centered on the screen
    data[byteindex] = (uint8_t)user->centerText << 7;
    byteindex += 1; // close bit field

    *bytecount = byteindex;

}// encodeClueOptionBits_t

/*!
 * \brief Decode a ClueOptionBits_t structure from a byte array
 *

 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodeClueOptionBits_t(const uint8_t* data, int* bytecount, ClueOptionBits_t* user)
{
    int byteindex = *bytecount;

    // Text is centered on the screen
    user->centerText = (data[byteindex] >> 7);
    byteindex += 1; // close bit field

    *bytecount = byteindex;

    return 1;

}// decodeClueOptionBits_t

/*!
 * \brief Verify a ClueOptionBits_t structure has acceptable values.
 *
 * Verify a ClueOptionBits_t structure has acceptable values. Not all fields are
 * verified, only those which the protocol specifies. Fields which are outside
 * the allowable range are changed to the maximum or minimum allowable value. 
 * \param user is the structure whose data are verified
 * \return 1 if all verifiable data where valid, else 0 if data had to be corrected
 */
int verifyClueOptionBits_t(ClueOptionBits_t* user)
{
    int good = 1;

    // Text is centered on the screen
    if(user->centerText > 1)
    {
        user->centerText = 1;
        good = 0;
    }

    return good;

}// verifyClueOptionBits_t

/*!
 * \brief Encode a Waypoint_t structure into a byte array
 *

 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodeWaypoint_t(uint8_t* data, int* bytecount, const Waypoint_t* user)
{
    int byteindex = *bytecount;

    // Location latitude
    float32ToBeBytes((float)user->lat, data, &byteindex);

    // Location longitude
    float32ToBeBytes((float)user->lng, data, &byteindex);

    // Distance threshold (m)
    uint16ToBeBytes((uint16_t)user->threshold, data, &byteindex);

    // Clue type
    uint8ToBytes((uint8_t)user->type, data, &byteindex);

    // Extra clue options
    encodeClueOptionBits_t(data, &byteindex, &user->options);

    *bytecount = byteindex;

}// encodeWaypoint_t

/*!
 * \brief Decode a Waypoint_t structure from a byte array
 *

 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodeWaypoint_t(const uint8_t* data, int* bytecount, Waypoint_t* user)
{
    int byteindex = *bytecount;

    // Location latitude
    user->lat = float32FromBeBytes(data, &byteindex);

    // Location longitude
    user->lng = float32FromBeBytes(data, &byteindex);

    // Distance threshold (m)
    user->threshold = (uint16_t)uint16FromBeBytes(data, &byteindex);

    // Clue type
    user->type = (uint8_t)uint8FromBytes(data, &byteindex);

    // Extra clue options
    if(decodeClueOptionBits_t(data, &byteindex, &user->options) == 0)
        return 0;

    *bytecount = byteindex;

    return 1;

}// decodeWaypoint_t

/*!
 * \brief Verify a Waypoint_t structure has acceptable values.
 *
 * Verify a Waypoint_t structure has acceptable values. Not all fields are
 * verified, only those which the protocol specifies. Fields which are outside
 * the allowable range are changed to the maximum or minimum allowable value. 
 * \param user is the structure whose data are verified
 * \return 1 if all verifiable data where valid, else 0 if data had to be corrected
 */
int verifyWaypoint_t(Waypoint_t* user)
{
    int good = 1;

    // Distance threshold (m)
    if(user->threshold < 25)
    {
        user->threshold = 25;
        good = 0;
    }
    else if(user->threshold > 500)
    {
        user->threshold = 500;
        good = 0;
    }

    // Extra clue options
    if(!verifyClueOptionBits_t(&user->options))
        good = 0;

    return good;

}// verifyWaypoint_t

/*!
 * \brief Encode a ClueLine_t structure into a byte array
 *

 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodeClueLine_t(uint8_t* data, int* bytecount, const ClueLine_t* user)
{
    int byteindex = *bytecount;

    stringToBytes(user->text, data, &byteindex, CLUE_LINE_LEN_MAX, 0);

    *bytecount = byteindex;

}// encodeClueLine_t

/*!
 * \brief Decode a ClueLine_t structure from a byte array
 *

 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodeClueLine_t(const uint8_t* data, int* bytecount, ClueLine_t* user)
{
    int byteindex = *bytecount;

    stringFromBytes(user->text, data, &byteindex, CLUE_LINE_LEN_MAX, 0);

    *bytecount = byteindex;

    return 1;

}// decodeClueLine_t

/*!
 * \brief Encode a Clue_t structure into a byte array
 *

 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodeClue_t(uint8_t* data, int* bytecount, const Clue_t* user)
{
    int byteindex = *bytecount;
    int i = 0;

    // Waypoint data
    encodeWaypoint_t(data, &byteindex, &user->waypoint);

    // Text data
    for(i = 0; i < NUM_CLUE_LINES; i++)
        encodeClueLine_t(data, &byteindex, &user->lines[i]);

    // Clue checksum
    uint32ToBeBytes((uint32_t)user->checksum, data, &byteindex);

    *bytecount = byteindex;

}// encodeClue_t

/*!
 * \brief Decode a Clue_t structure from a byte array
 *

 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodeClue_t(const uint8_t* data, int* bytecount, Clue_t* user)
{
    int byteindex = *bytecount;
    int i = 0;

    // Waypoint data
    if(decodeWaypoint_t(data, &byteindex, &user->waypoint) == 0)
        return 0;

    // Text data
    for(i = 0; i < NUM_CLUE_LINES; i++)
    {
        if(decodeClueLine_t(data, &byteindex, &user->lines[i]) == 0)
            return 0;
    }

    // Clue checksum
    user->checksum = (uint32_t)uint32FromBeBytes(data, &byteindex);

    *bytecount = byteindex;

    return 1;

}// decodeClue_t

/*!
 * \brief Verify a Clue_t structure has acceptable values.
 *
 * Verify a Clue_t structure has acceptable values. Not all fields are
 * verified, only those which the protocol specifies. Fields which are outside
 * the allowable range are changed to the maximum or minimum allowable value. 
 * \param user is the structure whose data are verified
 * \return 1 if all verifiable data where valid, else 0 if data had to be corrected
 */
int verifyClue_t(Clue_t* user)
{
    int good = 1;
    int i = 0;

    // Waypoint data
    if(!verifyWaypoint_t(&user->waypoint))
        good = 0;

    // Text data
    for(i = 0; i < NUM_CLUE_LINES; i++)
        if(!verifyClueLine_t(&user->lines[i]))
            good = 0;

    return good;

}// verifyClue_t

// end of boxdefines.c
