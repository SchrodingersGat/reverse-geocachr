// fielddecode.c was generated by ProtoGen version 1.4.1.a

#include "fielddecode.h"


/*!
 * Decode a null terminated string from a byte stream
 * \param string receives the deocded null-terminated string.
 * \param bytes is a pointer to the byte stream to be decoded.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by the number of bytes decoded when this function
 *        is complete.
 * \param maxLength is the maximum number of bytes that can be decoded.
 *        maxLength includes the null terminator, which is always applied.
 * \param fixedLength should be 1 to force the number of bytes decoded to be
 *        exactly equal to maxLength.
 */
void stringFromBytes(char* string, const uint8_t* bytes, int* index, int maxLength, int fixedLength)
{
    int i;

    // increment byte pointer for starting point
    bytes += *index;

    for(i = 0; i < maxLength - 1; i++)
    {
        if(bytes[i] == 0)
            break;
        else
            string[i] = (char)bytes[i];
    }

    // Make sure we include null terminator
    string[i++] = 0;

    if(fixedLength)
        (*index) += maxLength;
    else
        (*index) += i;

}// stringFromBytes

/*!
 * Encode a 4 byte float on a big endian byte stream.
 * \param bytes is a pointer to the byte stream which contains the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \return the number decoded from the byte stream
 */
float float32FromBeBytes(const uint8_t* bytes, int* index)
{
    union
    {
        float floatValue;
        uint32_t integerValue;
    }field;

    field.integerValue = uint32FromBeBytes(bytes, index);

    return field.floatValue;
}


/*!
 * Encode a 4 byte float on a little endian byte stream.
 * \param bytes is a pointer to the byte stream which contains the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \return the number decoded from the byte stream
 */
float float32FromLeBytes(const uint8_t* bytes, int* index)
{
    union
    {
        float floatValue;
        uint32_t integerValue;
    }field;

    field.integerValue = uint32FromLeBytes(bytes, index);

    return field.floatValue;
}


/*!
 * Encode a unsigned 4 byte integer on a big endian byte stream.
 * \param bytes is a pointer to the byte stream which contains the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \return the number decoded from the byte stream
 */
uint32_t uint32FromBeBytes(const uint8_t* bytes, int* index)
{
    uint32_t number;

    // increment byte pointer for starting point
    bytes += *index;

    number = *(bytes++);
    number = (number << 8) | *(bytes++);
    number = (number << 8) | *(bytes++);
    number = (number << 8) | *bytes;

    (*index) += 4;

    return number;
}


/*!
 * Encode a unsigned 4 byte integer on a little endian byte stream.
 * \param bytes is a pointer to the byte stream which contains the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \return the number decoded from the byte stream
 */
uint32_t uint32FromLeBytes(const uint8_t* bytes, int* index)
{
    uint32_t number;

    // increment byte pointer for starting point
    bytes += (*index) + 3;

    number = *(bytes--);
    number = (number << 8) | *(bytes--);
    number = (number << 8) | *(bytes--);
    number = (number << 8) | *bytes;

    (*index) += 4;

    return number;
}


/*!
 * Encode a signed 4 byte integer on a big endian byte stream.
 * \param bytes is a pointer to the byte stream which contains the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \return the number decoded from the byte stream
 */
int32_t int32FromBeBytes(const uint8_t* bytes, int* index)
{
    int32_t number;

    // increment byte pointer for starting point
    bytes += *index;

    number = *(bytes++);
    number = (number << 8) | *(bytes++);
    number = (number << 8) | *(bytes++);
    number = (number << 8) | *bytes;

    (*index) += 4;

    return number;
}


/*!
 * Encode a signed 4 byte integer on a little endian byte stream.
 * \param bytes is a pointer to the byte stream which contains the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \return the number decoded from the byte stream
 */
int32_t int32FromLeBytes(const uint8_t* bytes, int* index)
{
    int32_t number;

    // increment byte pointer for starting point
    bytes += (*index) + 3;

    number = *(bytes--);
    number = (number << 8) | *(bytes--);
    number = (number << 8) | *(bytes--);
    number = (number << 8) | *bytes;

    (*index) += 4;

    return number;
}


/*!
 * Encode a unsigned 3 byte integer on a big endian byte stream.
 * \param bytes is a pointer to the byte stream which contains the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \return the number decoded from the byte stream
 */
uint32_t uint24FromBeBytes(const uint8_t* bytes, int* index)
{
    uint32_t number;

    // increment byte pointer for starting point
    bytes += *index;

    number = *(bytes++);
    number = (number << 8) | *(bytes++);
    number = (number << 8) | *bytes;

    (*index) += 3;

    return number;
}


/*!
 * Encode a unsigned 3 byte integer on a little endian byte stream.
 * \param bytes is a pointer to the byte stream which contains the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \return the number decoded from the byte stream
 */
uint32_t uint24FromLeBytes(const uint8_t* bytes, int* index)
{
    uint32_t number;

    // increment byte pointer for starting point
    bytes += (*index) + 2;

    number = *(bytes--);
    number = (number << 8) | *(bytes--);
    number = (number << 8) | *bytes;

    (*index) += 3;

    return number;
}


/*!
 * Encode a signed 3 byte integer on a big endian byte stream.
 * \param bytes is a pointer to the byte stream which contains the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \return the number decoded from the byte stream
 */
int32_t int24FromBeBytes(const uint8_t* bytes, int* index)
{
    // Signed value in non-native size, requires sign extension. Algorithm
    // courtesty of: https://graphics.stanford.edu/~seander/bithacks.html
    const int32_t m = 0x00800000;
    int32_t number;

    // increment byte pointer for starting point
    bytes += *index;

    number = *(bytes++);
    number = (number << 8) | *(bytes++);
    number = (number << 8) | *bytes;

    (*index) += 3;

    return (number ^ m) - m;
}


/*!
 * Encode a signed 3 byte integer on a little endian byte stream.
 * \param bytes is a pointer to the byte stream which contains the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \return the number decoded from the byte stream
 */
int32_t int24FromLeBytes(const uint8_t* bytes, int* index)
{
    // Signed value in non-native size, requires sign extension. Algorithm
    // courtesty of: https://graphics.stanford.edu/~seander/bithacks.html
    const int32_t m = 0x00800000;
    int32_t number;

    // increment byte pointer for starting point
    bytes += (*index) + 2;

    number = *(bytes--);
    number = (number << 8) | *(bytes--);
    number = (number << 8) | *bytes;

    (*index) += 3;

    return (number ^ m) - m;
}


/*!
 * Encode a unsigned 2 byte integer on a big endian byte stream.
 * \param bytes is a pointer to the byte stream which contains the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \return the number decoded from the byte stream
 */
uint16_t uint16FromBeBytes(const uint8_t* bytes, int* index)
{
    uint16_t number;

    // increment byte pointer for starting point
    bytes += *index;

    number = *(bytes++);
    number = (number << 8) | *bytes;

    (*index) += 2;

    return number;
}


/*!
 * Encode a unsigned 2 byte integer on a little endian byte stream.
 * \param bytes is a pointer to the byte stream which contains the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \return the number decoded from the byte stream
 */
uint16_t uint16FromLeBytes(const uint8_t* bytes, int* index)
{
    uint16_t number;

    // increment byte pointer for starting point
    bytes += (*index) + 1;

    number = *(bytes--);
    number = (number << 8) | *bytes;

    (*index) += 2;

    return number;
}


/*!
 * Encode a signed 2 byte integer on a big endian byte stream.
 * \param bytes is a pointer to the byte stream which contains the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \return the number decoded from the byte stream
 */
int16_t int16FromBeBytes(const uint8_t* bytes, int* index)
{
    int16_t number;

    // increment byte pointer for starting point
    bytes += *index;

    number = *(bytes++);
    number = (number << 8) | *bytes;

    (*index) += 2;

    return number;
}


/*!
 * Encode a signed 2 byte integer on a little endian byte stream.
 * \param bytes is a pointer to the byte stream which contains the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \return the number decoded from the byte stream
 */
int16_t int16FromLeBytes(const uint8_t* bytes, int* index)
{
    int16_t number;

    // increment byte pointer for starting point
    bytes += (*index) + 1;

    number = *(bytes--);
    number = (number << 8) | *bytes;

    (*index) += 2;

    return number;
}


/*!
 * Encode a unsigned 1 byte integer on a byte stream.
 * \param bytes is a pointer to the byte stream which contains the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \return the number decoded from the byte stream
 */
uint8_t uint8FromBytes(const uint8_t* bytes, int* index)
{
    return (uint8_t)bytes[(*index)++];
}


/*!
 * Encode a signed 1 byte integer on a byte stream.
 * \param bytes is a pointer to the byte stream which contains the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \return the number decoded from the byte stream
 */
int8_t int8FromBytes(const uint8_t* bytes, int* index)
{
    return (int8_t)bytes[(*index)++];
}


// end of fielddecode.c
