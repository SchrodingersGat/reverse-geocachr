latex input: mmd-article-header 
Title: ReverseGeocache Protocol  
Base Header Level: 1 
latex input: mmd-article-begin-doc

<style>
    body {
        text-align:justify;
        width: 1000px;
        background-color:#eee;
        margin-left: auto;
        margin-right: auto;
        font-family:Verdana;
        counter-reset: h1counter;    }

    table {
       border: 3px solid darkred;
       border-collapse: collapse;
    }

    th, td {
       border: 1px solid green;
       font-family: Courier New, monospace;
    }

    td{ padding: 2px; }
    h1, h2, h3, h4, h5 { font-family: Arial; }
    h1 { font-size:150%; }
    h2 { font-size:135%; }
    h3 { font-size:120%; }
    h4 { font-size:110%; }
    h5, li { font-size:100%; }
    caption{ font-family:Verdana; }

    code, pre, .codelike {
        font-family: Courier New, monospace;
        font-size: 100%;
        color: darkblue;
    }
    h1:before {
      content: counter(h1counter) "\00a0 ";
      counter-increment: h1counter;
      counter-reset: h2counter;
    }
    h1 {
      counter-reset: h2counter;
    }
    h2:before {
      content: counter(h1counter) "." counter(h2counter) "\00a0 ";
      counter-increment: h2counter;
      counter-reset: h3counter;
    }
    h3:before {
      content: counter(h1counter) "." counter(h2counter) "." counter(h3counter) "\00a0 ";
      counter-increment: h3counter;
    }</style>

# ReverseGeocache Protocol

Data *on the wire* are sent in BIG endian format. Any field larger than one byte is sent with the most signficant byte first, and the least significant byte last

ReverseGeocache Protocol version is 1.0.0.a.

ReverseGeocache Protocol API is 1.

----------------------------

# About this ICD

This is the interface control document for data *on the wire*, not data in memory. This document was automatically generated by the [ProtoGen software](https://github.com/billvaglienti/ProtoGen), version 1.4.1.a. ProtoGen also generates C source code for doing most of the work of encoding data from memory to the wire, and vice versa. Documentation for software developers (i.e. data *in memory*) is separately produced as a doxygen product, parsing comments embedded in the automatically generated code.

# Encodings

Data can be encoded as unsigned integers, signed integers (two's complement), bitfields, and floating point.

| <a name="Enc"></a>Encoding | Interpretation                        | Notes                                                                       |
| :--------------------------: | ------------------------------------- | --------------------------------------------------------------------------- |
| UX                           | Unsigned integer X bits long          | X must be: 8, 16, 24, 32, 40, 48, 56, or 64                                 |
| IX                           | Signed integer X bits long            | X must be: 8, 16, 24, 32, 40, 48, 56, or 64                                 |
| BX                           | Unsigned integer bitfield X bits long | X must be greater than 0 and less than 32                                   |
| F16                          | 16 bit floating point                 | 1 sign bit : 6 exponent bits : 9 significant bits with implied leading 1    |
| F24                          | 24 bit floating point                 | 1 sign bit : 8 exponent bits : 15 significant bits with implied leading 1   |
| F32                          | 32 bit floating point (IEEE-754)      | 1 sign bit : 8 exponent bits : 23 significant bits with implied leading 1   |
| F64                          | 64 bit floating point (IEEE-754)      | 1 sign bit : 11 exponent bits : 52 significant bits with implied leading 1  |

# Size of fields
The encoding tables give the bytes for each field as X...Y; where X is the first byte (counting from 0) and Y is the last byte. For example a 4 byte field at the beginning of a packet will give 0...3. If the field is 1 byte long then only the starting byte is given. Bitfields are more complex, they are displayed as Byte:Bit. A 3-bit bitfield at the beginning of a packet will give 0:7...0:5, indicating that the bitfield uses bits 7, 6, and 5 of byte 0. Note that the most signficant bit of a byte is 7, and the least signficant bit is 0. If the bitfield is 1 bit long then only the starting bit is given.

The byte count in the encoding tables are based on the maximum length of the field(s). If a field is variable length then the actual byte location of the data may be different depending on the value of the variable field. If the field is a variable length character string this will be indicated in the encoding column of the table. If the field is a variable length array this will be indicated in the repeat column of the encoding table. If the field depends on the non-zero value of another field then will be indicated in the description column of the table.

----------------------------

# Enumerations

ReverseGeocache protocol defines these global enumerations.

## Packet

[<a name="Packet"></a>Packet: USB Packet types]
| Name                                              | Value | Description |
| ------------------------------------------------- | :---: | ----------- |
| [`RESET_INTO_BOOTLOADER`](#RESET_INTO_BOOTLOADER) | 10    |             |
| [`ENABLE_DEBUG_MODE`](#ENABLE_DEBUG_MODE)         | 11    |             |
| [`SYSTEM_INFO`](#SYSTEM_INFO)                     | 160   |             |
| [`CLUE_INFO`](#CLUE_INFO)                         | 176   |             |
| [`CLUE_LINE`](#CLUE_LINE)                         | 192   |             |
| [`UNLOCK`](#UNLOCK)                               | 208   |             |
| [`LOCK`](#LOCK)                                   | 209   |             |
| [`NEXT_CLUE`](#NEXT_CLUE)                         | 224   |             |
| [`PREV_CLUE`](#PREV_CLUE)                         | 225   |             |
| [`FIRST_CLUE`](#FIRST_CLUE)                       | 226   |             |
| [`LAST_CLUE`](#LAST_CLUE)                         | 227   |             |
| [`SET_CLUE_COUNT`](#SET_CLUE_COUNT)               | 240   |             |
| `INVALIDATE_CLUES`                                | 241   |             |
| [`VALIDATE_CLUES`](#VALIDATE_CLUES)               | 242   |             |


## ClueTypes

[<a name="ClueTypes"></a>ClueTypes]
| Name                 | Value | Description |
| -------------------- | :---: | ----------- |
| `CLUE_NO_HINT`       | 0     |             |
| `CLUE_SHOW_DISTANCE` | 1     |             |
| `CLUE_SHOW_LOCATION` | 2     |             |
| `CLUE_WARMER_COOLER` | 3     |             |
| `CLUE_SHOW_HEADING`  | 4     |             |
| `CLUE_SHOW_CARDINAL` | 5     |             |
| `NUM_CLUE_TYPES`     | 6     |             |


----------------------------

# Packets

This section describes the data payloads of the packets; and how those data are represented in the bytes of the packets.

## <a name="UNLOCK"></a>Unlock

- packet identifier: `UNLOCK` : 208
- data length: 

## <a name="LOCK"></a>Lock

- packet identifier: `LOCK` : 209
- data length: 

## <a name="NEXT_CLUE"></a>NextClue

- packet identifier: `NEXT_CLUE` : 224
- data length: 

## <a name="PREV_CLUE"></a>PrevClue

- packet identifier: `PREV_CLUE` : 225
- data length: 

## <a name="FIRST_CLUE"></a>FirstClue

- packet identifier: `FIRST_CLUE` : 226
- data length: 

## <a name="LAST_CLUE"></a>LAST_CLUE

- packet identifier: `LAST_CLUE` : 227
- data length: 

## <a name="RESET_INTO_BOOTLOADER"></a>Bootload

- packet identifier: `RESET_INTO_BOOTLOADER` : 10
- data length: 

## <a name="ENABLE_DEBUG_MODE"></a>EnableDebug

- packet identifier: `ENABLE_DEBUG_MODE` : 11
- data length: 

## <a name="SET_CLUE_COUNT"></a>SetClueCount

- packet identifier: `SET_CLUE_COUNT` : 240
- data length: 1

### SetClueCount encoding


[Encoding for packet SetClueCount]
| Bytes | Name        | [Enc](#Enc) | Repeat | Description |
| ----- | ----------- | :---------: | :----: | ----------- |
| 0     | 1)clueCount | U8          | 1      |             |


## <a name="VALIDATE_CLUES"></a>ValidateClues

- packet identifier: `VALIDATE_CLUES` : 242
- data length: 

## <a name="VALIDATE_CLUES"></a>InvalidateClues

- packet identifier: `VALIDATE_CLUES` : 242
- data length: 

## <a name="SYSTEM_INFO"></a>BoxInfo

- packet identifier: `SYSTEM_INFO` : 160
- data length: 9

### BoxInfo encoding


[Encoding for packet BoxInfo]
| Bytes | Name             | [Enc](#Enc) | Repeat | Description |
| ----- | ---------------- | :---------: | :----: | ----------- |
| 0...8 | 1)info                        || 1      |             |
| 0...1 | 1.1)serialNumber | U16         | 1      |             |
| 2     | 1.2)versionMajor | U8          | 1      |             |
| 3     | 1.3)versionMinor | U8          | 1      |             |
| 4     | 1.4)pcbRevision  | U8          | 1      |             |
| 5     | 1.5)status                    || 1      |             |
| 5:7   | 1.5.1)locked     | B1          | 1      |             |
| 6     | 1.6)charge       | U8          | 1      |             |
| 7     | 1.7)currentClue  | U8          | 1      |             |
| 8     | 1.8)totalClues   | U8          | 1      |             |


## <a name="SYSTEM_INFO"></a>RequestBoxInfo

- packet identifier: `SYSTEM_INFO` : 160
- data length: 

## <a name="CLUE_INFO"></a>ClueInfo

- packet identifier: `CLUE_INFO` : 176
- data length: 21

### ClueInfo encoding


[Encoding for packet ClueInfo]
| Bytes   | Name                   | [Enc](#Enc) | Repeat | Description |
| ------- | ---------------------- | :---------: | :----: | ----------- |
| 0       | 1)clueNumber           | U8          | 1      |             |
| 1...20  | 2)clueInfo                          || 1      |             |
| 1...8   | 2.1)lat                | F64         | 1      |             |
| 9...16  | 2.2)lng                | F64         | 1      |             |
| 17...18 | 2.3)threshold          | U16         | 1      |             |
| 19      | 2.4)[type](#ClueTypes) | U8          | 1      |             |
| 20      | 2.5)options                         || 1      |             |
| 20:7    | 2.5.1)centerText       | B1          | 1      |             |


## <a name="CLUE_INFO"></a>RequestClueInfo

- packet identifier: `CLUE_INFO` : 176
- data length: 1

### RequestClueInfo encoding


[Encoding for packet RequestClueInfo]
| Bytes | Name         | [Enc](#Enc) | Repeat | Description |
| ----- | ------------ | :---------: | :----: | ----------- |
| 0     | 1)clueNumber | U8          | 1      |             |


## <a name="CLUE_LINE"></a>ClueLine

- packet identifier: `CLUE_LINE` : 192
- minimum data length: 3
- maximum data length: 42

### ClueLine encoding


[Encoding for packet ClueLine]
| Bytes  | Name         | [Enc](#Enc)                           | Repeat | Description |
| ------ | ------------ | :-----------------------------------: | :----: | ----------- |
| 0      | 1)clueNumber | U8                                    | 1      |             |
| 1      | 2)lineNumber | U8                                    | 1      |             |
| 2...41 | 3)lineText   | Zero-terminated string up to 40 bytes         ||             |


## <a name="CLUE_LINE"></a>RequestClueLine

- packet identifier: `CLUE_LINE` : 192
- data length: 2

### RequestClueLine encoding


[Encoding for packet RequestClueLine]
| Bytes | Name         | [Enc](#Enc) | Repeat | Description |
| ----- | ------------ | :---------: | :----: | ----------- |
| 0     | 1)clueNumber | U8          | 1      |             |
| 1     | 2)lineNumber | U8          | 1      |             |


